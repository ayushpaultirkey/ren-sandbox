var F=Object.defineProperty;var M=(o,s,t)=>s in o?F(o,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[s]=t;var y=(o,s,t)=>(M(o,typeof s!="symbol"?s+"":s,t),t),C=(o,s,t)=>{if(!s.has(o))throw TypeError("Cannot "+t)};var r=(o,s,t)=>(C(o,s,"read from private field"),t?t.call(o):s.get(o)),u=(o,s,t)=>{if(s.has(o))throw TypeError("Cannot add the same private member more than once");s instanceof WeakSet?s.add(o):s.set(o,t)},p=(o,s,t,e)=>(C(o,s,"write to private field"),e?e.call(o,t):s.set(o,t),t);var l;class Y{constructor(){u(this,l,new Map)}on(s,t){r(this,l).has(s)||r(this,l).set(s,[]),r(this,l).get(s).push(t)}off(s,t){r(this,l).has(s)&&r(this,l).set(s,r(this,l).get(s).filter(e=>e!==t))}emit(s,...t){r(this,l).has(s)&&r(this,l).get(s).forEach(e=>e(...t))}once(s,t){const e=(...n)=>{this.off(s,e),t(...n)};this.on(s,e)}clear(s){r(this,l).has(s)&&(r(this,l).delete(s),console.warn(`Event ${s} cleared`))}clearAll(){r(this,l).clear(),console.warn("Event handler cleared")}}l=new WeakMap;var U,O,x,P,L;class b{constructor({uuid:s=crypto.randomUUID(),outer:t=null,name:e=null}={}){u(this,U,null);u(this,O,null);u(this,x,null);u(this,P,null);u(this,L,new Y);p(this,U,s),p(this,O,t),p(this,x,e)}get uuid(){return r(this,U)}get outer(){return r(this,O)}get name(){return r(this,x)}get signature(){return r(this,P)}set signature(s){r(this,P)?console.error("Cannot set signature once set"):p(this,P,s)}get dispatcher(){return r(this,L)}main(){}destroy(){r(this,L).clearAll()}get meta(){return this.constructor.meta}static getMeta(){return this.meta}}U=new WeakMap,O=new WeakMap,x=new WeakMap,P=new WeakMap,L=new WeakMap,y(b,"meta",{className:"IObject.IObject",displayName:"Object",description:"Object"});var h,g,D,S;const N=class N extends b{constructor({uuid:t=crypto.randomUUID(),outer:e=null,name:n=null,type:i=null,isRuntime:a=!1}={}){super({uuid:t,outer:e,name:n});u(this,h,[]);u(this,g,null);u(this,D,!1);u(this,S,null);p(this,g,i),p(this,h,[]),p(this,D,a),this.subType=-1,this.validSubTypes=new Set([]),this.maxLinks=1}get links(){return r(this,h)}get type(){return r(this,g)}get isRuntime(){return r(this,D)}getValue(){if(r(this,g)==N.TYPES.INPUT){const t=r(this,h)[0];if(!t)return null;const e=t.getNode();return e?(e.meta.canCache||e.execute(),t.getValue()):null}else return r(this,S)}getValues(){if(r(this,g)==N.TYPES.INPUT){const t=[];return r(this,h).forEach(e=>{if(e){const n=e.getValue();if(!n)return;t.push(n)}}),t}else return[r(this,S)]}setValue(t){if(r(this,g)==N.TYPES.INPUT){console.error("Cannot set input value");return}p(this,S,t)}getNode(){return this.outer}isAnyLinked(){return r(this,h).length>0}isLinked(t=0){return!!this.getLink(t)}getLink(t){return r(this,h)[t]}getLinkedNode(t){const e=this.getLink(t);return e?e.outer:null}canLinkTo(t){if(!t||!t.type||!t.outer||t.type==r(this,g)){console.error("Invalid socket, type, or same socket type");return}if(t.outer==this.outer){console.error("Source and target sockets are the same");return}if(r(this,g)==N.TYPES.INPUT&&!this.validSubTypes.has(t.subType)){console.error("Invalid sub-socket type");return}if(r(this,h).length>=this.maxLinks){console.error("Link limit failed");return}return!0}link(t){r(this,h).push(t)}unlink(t){p(this,h,r(this,h).filter(e=>e!=t))}clear(){p(this,h,[])}export(){let t=[];return this.type!==N.TYPES.OUTPUT||this.links.forEach(e=>{!e||!e.outer||!this.outer||t.push({sourceNode:this.outer.uuid,sourceSocket:this.uuid,targetNode:e.outer.uuid,targetSocket:e.uuid})}),t}};h=new WeakMap,g=new WeakMap,D=new WeakMap,S=new WeakMap,y(N,"meta",{className:"IObject.Socket",displayName:"Socket",displayColor:"gray"}),y(N,"TYPES",{INPUT:1,OUTPUT:2});let m=N;var k;class G extends b{constructor({uuid:t=crypto.randomUUID(),outer:e=null,type:n=null,value:i=null,custom:a={}}={}){super({uuid:t,outer:e});u(this,k,null);p(this,k,n),this.value=i,this.custom=a||{},this.custom.name=a.name||this.name,this.handler={}}get type(){return r(this,k)}export(){return{type:r(this,k),value:this.value,custom:this.custom}}}k=new WeakMap,y(G,"meta",{className:"IObject.IProperty",displayName:"Data"});const c={STRING:"STRING",BOOLEAN:"BOOLEAN",INTEGER:"INTEGER",FLOAT:"FLOAT",WILDCARD:"WILDCARD"},A={OBJECT:"OBJECT",GRAPH:"GRAPH",GRAPH_SET:"GRAPH_SET",REFERENCE:"REFERENCE"},J={FUNCTION:"FUNCTION",EVENT:"EVENT"};var T;class V extends b{constructor({uuid:t=crypto.randomUUID(),outer:e=null,name:n="Property Manager"}={}){super({uuid:t,outer:e,name:n});u(this,T,new Map)}main(t={}){try{for(const e in t){const n=t[e],i=n.type,a=n.value,E=n.custom;this.addProperty(e,i,a,E)}}catch(e){console.error(e)}}get properties(){return r(this,T)}addProperty(t,e,n=null,i={}){try{if(r(this,T).has(t))throw new Error(`PropertyManager: Property "${t}" already exists`);const a=c[e]||A[e];if(!a)throw new Error(`PropertyManager: Invalid type "${e}"`);const E=new G({uuid:t,outer:this,type:a,value:n,custom:i});r(this,T).set(t,E),this.dispatcher.emit("propertyAdded",E)}catch(a){console.error(a)}}removeProperty(t){return r(this,T).delete(t)?(this.dispatcher.emit("propertyRemoved",t),!0):!1}getProperty(t){try{if(!r(this,T).has(t))throw new Error(`PropertyManager: Property "${t}" does not exist`);return r(this,T).get(t)}catch(e){console.error(e)}}setProperty(t,e){try{if(!r(this,T).has(t))throw new Error(`PropertyManager: Property "${t}" does not exist`);const n=this.getProperty(t);n.value=e}catch(n){console.error(n)}}export(){const t=r(this,T),e={};for(const[n,i]of t){const a=i.export();a&&(e[n]=a)}return e}}T=new WeakMap,y(V,"meta",{className:"IObject.PropertyManager",displayName:"Property Manager"});class j extends m{constructor({uuid:s=crypto.randomUUID(),outer:t=null,name:e="wildcard",type:n=null,isRuntime:i=!1}){super({uuid:s,outer:t,name:e,type:n,isRuntime:i}),this.subType=c.WILDCARD,this.validSubTypes=new Set([c.WILDCARD,c.BOOLEAN,c.STRING,c.INTEGER,c.FLOAT,A.OBJECT,A.GRAPH_SET]),this.maxLinks=n==m.TYPES.OUTPUT?100:1}}y(j,"meta",{className:"ISocket.WildcardSocket",displayName:"Float",displayColor:"#607d8b"});class W extends m{constructor({uuid:s=crypto.randomUUID(),outer:t=null,name:e="integer",type:n=null,isRuntime:i=!1}){super({uuid:s,outer:t,name:e,type:n,isRuntime:i}),this.subType=c.INTEGER,this.validSubTypes=new Set([c.INTEGER,c.FLOAT]),this.maxLinks=n==m.TYPES.OUTPUT?100:1}setValue(s){const t=isNaN(s)?null:parseInt(s);super.setValue(t)}}y(W,"meta",{className:"ISocket.IntegerSocket",displayName:"Integer",displayColor:"#00a73e"});class B extends m{constructor({uuid:s=crypto.randomUUID(),outer:t=null,name:e="float",type:n=null,isRuntime:i=!1}){super({uuid:s,outer:t,name:e,type:n,isRuntime:i}),this.subType=c.FLOAT,this.validSubTypes=new Set([c.INTEGER,c.FLOAT]),this.maxLinks=n==m.TYPES.OUTPUT?100:1}setValue(s){const t=isNaN(s)?null:parseFloat(s);super.setValue(t)}}y(B,"meta",{className:"ISocket.FloatSocket",displayName:"Float",displayColor:"#059669"});class v extends m{constructor({uuid:s=crypto.randomUUID(),outer:t=null,name:e="string",type:n=null,isRuntime:i=!1}){super({uuid:s,outer:t,name:e,type:n,isRuntime:i}),this.subType=c.STRING,this.validSubTypes=new Set([c.STRING,c.WILDCARD]),this.maxLinks=n==m.TYPES.OUTPUT?100:1}setValue(s){const t=s?s.toString():null;super.setValue(t)}}y(v,"meta",{className:"ISocket.StringSocket",displayName:"String",displayColor:"#d946ef"});var I,f,d;class H extends b{constructor({uuid:t=crypto.randomUUID(),outer:e=null}={}){super({uuid:t,outer:e});u(this,I,null);u(this,f,{});u(this,d,{});this.custom={},this.isEntry=!1,p(this,I,new V({outer:this}))}get propertyManager(){return r(this,I)}get inputs(){return r(this,f)}get outputs(){return r(this,d)}main({properties:t={},custom:e={},inputs:n={},outputs:i={}}={}){try{e&&(this.custom=e);for(const a in n){const E=n[a],w=v;this.addInput(a,E.name,w,!0)}for(const a in i){const E=i[a],w=v;this.addOutput(a,E.name,w,!0)}for(const a in t){const E=t[a];r(this,I).setProperty(a,E.value)}return!0}catch(a){console.error(a)}}addInput(t,e,n,i=!1){if(!n||r(this,f)[t])return null;const a=new n({uuid:t,outer:this,name:e,type:m.TYPES.INPUT,isRuntime:i});return r(this,f)[t]=a,a}removeInput(t){if(r(this,f)[t].isRuntime)return delete r(this,f)[t],!0;console.error("Cannot remove static socket")}addOutput(t,e,n,i=!1){if(!n){console.error("Invalid socket class");return}if(r(this,d)[t]){console.error("Socket already exists");return}const a=new n({uuid:t,outer:this,name:e,type:m.TYPES.OUTPUT,isRuntime:i});return r(this,d)[t]=a,a}removeOutput(t){if(r(this,d)[t].isRuntime)return delete r(this,d)[t],!0;console.error("Cannot remove static socket")}getInput(t){return r(this,f)[t]}getOutput(t){return r(this,d)[t]}getSocket(t){return this.getInput(t)||this.getOutput(t)}execute(){}executeLinkedNode(t,e=0){const n=this.getSocket(t);if(n&&n.isLinked(e)){const i=n.getLinkedNode(e);i&&i.execute()}}customExport(){return null}export(){const t={class:this.meta.className,properties:r(this,I).export(),custom:this.custom||{},inputs:{},outputs:{}};for(const n in r(this,f)){const i=r(this,f)[n];i.isRuntime&&(t.inputs[n]={name:i.name||"in",type:i.subType})}for(const n in r(this,d)){const i=r(this,d)[n];i.isRuntime&&(t.outputs[n]={name:i.name||"out",type:i.subType})}let e=[];for(const n in r(this,d)){const i=r(this,d)[n];e=e.concat(i.export())}return{data:t,links:e}}}I=new WeakMap,f=new WeakMap,d=new WeakMap,y(H,"meta",{className:"IObject.INode",displayName:"Node",canCache:!0});const R=new Map,_={register:function(o){const s=o.meta.className;R.set(s,o)},registerMany:function(o=[]){for(const s of o)this.register(s)},unregister:function(o){const s=o.meta.className;return R.delete(s)},unregisterMany:function(o=[]){for(const s of o)this.unregister(s)},get:function(o){return R.get(o)},getAll:function(){return R.entries()},isRegistered:function(o){return R.has(o)}};export{J as D,B as F,m as I,_ as N,c as P,v as S,A as U,j as W,H as a,W as b,b as c,V as d};
